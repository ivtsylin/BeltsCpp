# Задание по программированию «Транспортный справочник, часть A»

В этой задаче и последующих её версиях вам нужно реализовать систему хранения транспортных маршрутов и обработки запросов к ней. Сначала на вход подаются запросы на создание базы данных, затем — запросы к самой базе.

При проектировании решения учитывайте, что его придётся неоднократно расширять. Авторские решения вы увидите лишь после успешной сдачи всех версий: таким образом, на протяжении всей череды доработок функционала вы будете иметь дело со своей собственной архитектурой кода и почувствуете, какие именно проектировочные решения мешают расширению.

## Формат ввода базы данных


В первой строке вводится количество запросов на обновление базы данных, затем — по одному на строке — вводятся сами запросы. Запросы бывают двух типов.

### Stop ***X: latitude, longitude***
Остановка с названием ***X*** и координатами ***latitude*** и ***longitude***.

Гарантируется, что остановка определена не более чем в одном запросе ***Stop X***.






- ```cpp
Json::Document XmlToJson(const Xml::Document& doc)
```
- ```cpp
Xml::Document JsonToXml(const Json::Document& doc, string root_name)
```

Кроме того, мы покрыли их юнит-тестами в функциях TestXmlToJson и TestJsonToXml. Но есть одна проблема — весь этот код писал начинающий специалист, который посмотрел все лекции нашего курса, но, не решив ни одной задачи, сразу стал применять полученные знания в работе. Он обратился к вам за помощью, передал свой код и, сказав: «Что-то у меня не компилируется», ушёл в отпуск. Ваша задача — привести в порядок код его функций и тестов, то есть сделать так, чтобы они компилировались и работали.

Более подробно, функция XmlToJson ожидает на вход документ, имеющий структуру \<root\>\<spend amount="2500" category="food"\>\</spend\>...\</root\>, то есть в корневом узле лежит ноль или больше узлов с именем "spend" и атрибутами "amount" и "category". Она должна возвращать объект класса Json::Document, имеющий структуру \[{"amount": 2500, "category": "food"}, ...\], то есть это массив, содержащий столько словарей, сколько было узлов \<spend\> в XML-документе. При этом в словарях узёл по ключу "amount" должен быть целочисленным, а по ключу "category" — строковым. Гарантируется, что в тестирующей системе на вход вашей функции будут подаваться только XML-документы, соответствующие описанному формату (то есть обрабатывать некорректный ввод в данной задаче не надо).

Функция JsonToXml должна выполнять обратное преобразование. Точно так же в нашей тестирующей системе ей на вход будут подаваться только JSON-документы, соответствующие описанному формату.

Тесты TestXmlToJson и TestJsonToXml не должны принимать пустые реализации функций XmlToJson и JsonToXml, а также реализации, нарушающие формат выходных данных. Вам не надо добавлять в тесты другие тестовые случаи, надо заставить компилироваться и работать те, которые есть.
