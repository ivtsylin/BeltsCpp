# Задание по программированию «Задача Optional»

В этой задаче вам надо реализовать шаблон класса Optional, который ведёт себя аналогично std::optional — может либо хранить элемент, либо хранить метку об отсутствии элемента. 

Обратите внимание, что Optional, в отличие от unique_ptr, должен хранить данные на стеке, а не в динамической памяти. Эти данные нужно проинициализировать только при необходимости (по умолчанию Optional создаётся пустым). Для этого нужно использовать конструкцию placement new — явное указание компилятору создать объект в указанном месте памяти. Например, сконструировать новый объект типа T в блоке памяти data можно так:
```cpp
new (data) T();
```

За временем жизни такого объекта придётся следить самостоятельно. Сама сырая память data в данном случае будет удалена автоматически, но деструктор придётся позвать вручную:
```cpp
reinterpret_cast<T*>(data)->~T();
```

Запомните: конструирование объекта с помощью placement new в уже имеющейся памяти, как в этой задаче, — это единственный случай, когда нужно вызывать деструктор самостоятельно. Пытайтесь не создавать лишние объекты типа T зря. Например, при присваивании нового объекта уже заполненному Optional просто вызовите соответствующий оператор присваивания для типа T. На проверку пришлите .cpp или .h файл с реализацией шаблона Optional. 

**<u>Замечание.</u>** Настоящий std::optional реализован сложнее. Просто конструировать объект в буфере байт на стеке он не может: тогда такой std::optional нельзя было бы использовать в constexpr-выражениях. Вместо этого в стандартном std::optional применяется union. Однако в этой задаче вполне достаточно использовать обычный буфер.
