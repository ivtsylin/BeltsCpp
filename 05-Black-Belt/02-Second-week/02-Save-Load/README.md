# Задание по программированию «Задача Save & Load»

В лекциях мы с вами видели, что бинарная (де)сериализация значения переменной простого типа T (int, char, double, bool и т.д.) выполняется так:
```cpp
T x = ...;
output_stream.write(reinterpret_cast<const char*>(&x), sizeof(x));
input_stream.read(reinterpret_cast<char*>(&x), sizeof(x));
```

Этот способ неудобен по многим причинам:
- код выглядит довольно громоздким;
- имя переменной используется дважды;
- использование reinterpret_cast и сырых указателей может повышать подозрительность читающего код.

Кроме того, если нам надо сохранять значения большого количества переменных (а обычно это так), то у нас получится очень тяжёлый для поддержки код. Наконец, такой способ бинарной сериализации в общем случае неприменим для сложных типов: структур и классов. Поэтому в этой задаче мы с вами разработаем удобную в использовании библиотеку для бинарной (де)сериализации примитивных типов, строк, а также контейнеров std::vector и std::map. Интерфейс этой библиотеки крайне прост:
- если у нас есть переменная x типа T и выходной поток output, то сериализация выполняется вызовом Serialize(x, output);
- если же у нас есть переменная x типа T и входной поток input, то десериализация выполняется вызовом Deserialize(input, x). 

Важные замечания:
- библиотека должна уметь (де)сериализовать составные контейнеры (например, std::vector<std::map<int, std::string>>);
- заголовки функций, которые вам надо написать, представлены в файле saveload.h;
- при сериализации любого контейнера сначала записывается число типа size_t — размер контейнера, — а затем уже сами элементы;
- для std::map записывайте элементы как пары, состоящие из ключа и значения;
- функции Deserialize должны восстанавливать исходный объект по сериализованному представлению. 

Пусть, например, требуется сериализовать
```cpp
std::map<uint32_t, std::string> m = {
  {1, "hello"},
  {2, "bye"},
};
```
На 64-битной платформе с порядком от младшего к старшему (наверняка ваш компьютер именно такой) должен получиться следующий результат (тут показан вывод консольной Linux-утилиты hd, применённый к полученному бинарному файлу):
```console
00000000  02 00 00 00 00 00 00 00  01 00 00 00 05 00 00 00  |................|
00000010  00 00 00 00 68 65 6c 6c  6f 02 00 00 00 03 00 00  |....hello.......|
00000020  00 00 00 00 00 62 79 65                           |.....bye|
```

Для простоты в этой задаче не нужно учитывать выравнивание (alignment) и можно считать, что порядок байт (endianness) при сериализации и десериализации будет одинаковым. Подробнее про эти тонкости вы узнаете из следующих частей курса, а сейчас просто не думайте об этом. 

На проверку пришлите файл saveload.h с реализацией всех функций Serialize и Deserialize.


